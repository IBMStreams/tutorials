---
layout: docs
title:  Monitoring jobs
description:
weight: 530
---

# Monitoring jobs
---

1. 	Maximize the **Streams Graph** card. You can also enlarge it, using the resize handle   at the bottom right of the card, just enough to show the entire graph. Move it to another position and remove other cards as you see fit.

  The graph is familiar from the **Instance Graph** in Studio, though it represents information in slightly different ways. It labels every stream with the tuple rate, and indicates operator health by a colored dot. As in the **Instance Graph**, relative tuple rate sets the thickness of the arrow. Usually the **Throttled** stream, at 40 tuples per second (give or take a few), is the thickest, but every so often the **Observations** stream, normally at zero, exceeds it. You observed the same behavior in the **Flow Rate Chart**.

  The **Streams Graph** is an alternative to the **Summary** card to detect trouble (unhealthy PEs), and to identify bottlenecks that may affect throughput performance. A bottleneck is an operator that limits the flow of tuples, usually because it cannot process any more tuples per second with the CPU cycles it has. If you did the optional section on indentifying problems as they occur, you saw that the Throttle operator was the cause of congestion that builds up over time.

<div class="alert alert-info" role="alert">
<h4><b>An artificial bottleneck</b></h4>
In most “real” applications, there is no place for a Throttle operator; you only used it here to simulate a data source with a manageable flow rate. Here, it also serves as a useful illustration of the concept of back pressure, and of the tools for identifying real bottlenecks.
</div>

  Even if congestion has not yet built up, a good indicator of a candidate for a bottleneck is a PE that consumes lots of CPU cycles: it would be toward the top in the **PE Metrics Scatter Chart**.

2. 	Hover over the topmost point(s) in the PE Metrics Scatter Chart (highest in CPU consumption).
Chances are, the operator is called **Throttled**. Apparently, the Throttle operator consumes CPU cycles to slow down the flow, while all the others are reading and writing files, or filtering and aggregating tuples, at very low CPU cost.
Of course, as long as the PE keeps up with the tuple flow, high CPU load doesn’t necessarily mean bottleneck. In this case, it is not apparent until the job has run for a long time that the Throttle operator is indeed a bottleneck.

## Visualizing data flow

Data is carried in tuples; tuples flow on streams. To view data, you have to monitor a stream.
1. 	In the Streams graph, hover over the Filtered stream (from Filtered to Averaged). In the panel that pops up, click Create View.

1. 	Data Visualization Views are comparable to the Show Data views in Studio.

    a. 	In the Basics tab, change the View Name to something more descriptive: for example, Filtered cars. Edit the View Description if you like, but this is not important.
  
    b. 	In the Buffer tab, set the Tuples/sec Throttle to 5. Because each car reports about once per second and the Filtered stream only represents two cars, this should allow the view to keep up with all selected tuples without throttling (subsampling).
  
    c. 	In Buffer Size Configuration, keep the Limit By option of Tuple Count and set it to 50.

    d. 	Explore the table as shown below. The whole table contains 50 rows. Click 50 at the bottom of the card to make a single page. Click the id column header to sort by id and scroll up and down to see a short history of each car. Click the time column header (the last one, not the first column Time, which is not an attribute but a column generated by the view) twice to see the latest tuples at the top. Resize columns and card as needed.
    
<img width="60%" src="/tutorials/images/Lab3/1.JPG"/>

1. 	It’s easier to interpret numerical data when you depict it graphically. Let’s look at speed and heading. Since they have different numeric ranges, it’s best to show them in separate charts. Speed first.
  
1. 	In the data visualization view, click **Create Chart**.
  
2. 	In the **Chart** tab of the **Create Time Series Line Chart** dialog, adjust the **Chart name** as you see fit; for example, set it to `Filtered Cars: Speed`.
  
3. 	In the **Categories** tab:  
      Select **Values of One Attribute:**  
      Set **Measured by (Y-Axis)** to **speed**  
      Set **Plot Lines With Values Of:** to **id**  
      Keep **All Values** selected

1. 	Next, heading. Perform the same steps as in step 3 but choose **heading** in **Measured by**, and set an appropriate Chart name.

1. 	To create a comparative view of the effect of the aggregation analytic you added to the application in this part, create a data visualization view of the **Averaged** stream and create a chart showing the average speed for both cars. Use steps 1 through 3, with appropriate substitutions for stream and attribute names.

  You now can gain more insight in your data by inspecting it visually. For example, it becomes clear that the heading makes big jumps between relatively constant periods; this makes sense in an American city, where most turns are 90 degrees. Also, the speed, while in principle a measured quantity best represented by a floating-point number, is only reported as whole numbers (this is also obvious from the table view), lending a stair-step quality to the plot; this may mean that some efficiency can be gained by changing the attribute type to `int32` or even `int16` or `int8`, provided that it can be verified that no source will ever have non-integer speed values.

  When you are ready to move on to the next module, close or minimize the browser and go back to Studio.

 {% include nextPageFinder.html context=page.url %}
 
